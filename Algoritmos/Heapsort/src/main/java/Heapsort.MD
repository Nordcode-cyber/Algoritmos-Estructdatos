   # HeapSort
                                                                         
                        Método de ordenamiento por Montículo,  algoritmo de  Árbol Binario con Recursividad.
El algoritmo empieza con un vector de N elementos que no cumple la condición de montículo. Lo primero que hace el algoritmo es construir el montículo de partida. Para ello, considera el montículo como una estructura recursiva. Se puede considerar que los nodos del montículo del último nivel del árbol son cada uno un sub montículo de 1 nodo. Subiendo un nivel en el árbol, cada nodo es la raíz de un árbol que cumple la condición del montículo, excepto, quizás, en la raíz (su rama izquierda y derecha cumplen la condición, ya que se está construyendo de abajo a arriba); entonces, al aplicar el método criba() (reconstruye el montículo hundiendo la raíz), se asegura que cumple la condición de ordenación y ya es submontículo. El algoritmo va subiendo de nivel en nivel, construyendo tantos sub montículos como nodos tiene el nivel, hasta llegar al primer nivel, en el que sólo hay un nodo, que es la raíz del montículo completo.

                                      Explicación lógica del algoritmo Heapsort:
El algoritmo Heapsort es un algoritmo de ordenamiento basado en la estructura de datos "heap". Un heap es un árbol binario completo en el que cada nodo padre es mayor (o menor) que sus hijos. El proceso de ordenamiento comienza construyendo un heap a partir de la lista desordenada.Para construir el heap, se insertan todos los elementos de la lista, en el heap uno por uno, comenzando desde la izquierda y moviéndose hacia la derecha. Cada vez que se inserta un elemento en el heap, se asegura que la propiedad del heap se mantenga (es decir, cada nodo padre es mayor o menor que sus hijos). Una vez que se ha construido el heap, se extrae el elemento máximo del heap (que siempre es la raíz del árbol). El elemento máximo se coloca al final de la lista ordenada. Luego, se reorganiza el heap para asegurarse de que la propiedad del heap se mantenga después de la eliminación del elemento máximo. Este proceso se repite hasta que todos los elementos del heap se han eliminado y se han agregado a la lista ordenada. La lista ordenada final es la lista original de elementos, pero en orden ascendente o descendente según la elección de implementación del heap. En resumen, el algoritmo Heapsort construye un heap a partir de la lista desordenada, extrae el elemento máximo del heap y lo coloca al final de la lista ordenada, y repite este proceso hasta que todos los elementos del heap se han eliminado y se han agregado a la lista ordenada.

                                     Metodo de Intercambio del algoritmo Heapsort
La fase de extracción de los elementos en orden tarda O(n log n) tiempo en el peor de los casos. La razón de esto se debe al hecho de que cada extracción de un elemento del montículo toma O(log n) tiempo en el peor de los casos. Esto se debe a que después de cada extracción, el montículo debe ser restaurado a un estado válido mediante una serie de intercambios y comparaciones de elementos. En el peor de los casos, esto implica descender por la altura completa del árbol binario completo que representa el montículo, lo que tiene una complejidad de O(log n).

En total, el tiempo de ejecución de Heapsort en el peor de los casos es O(n log n), ya que la fase de construcción del montículo y la fase de extracción de los elementos en orden tienen complejidades de O(n) y O(n log n), respectivamente. En resumen, el análisis logarítmico de Heapsort se basa en el hecho de que la extracción de cada elemento del montículo toma O(log n) tiempo en el peor de los casos debido a la altura del árbol binario completo que representa el montículo. Esto da lugar a una complejidad total de O(n log n) para el algoritmo en el peor de los casos.

                                  Notación asintótica complejidad temporal O(log n) ?
O(log n) es una notación asintótica que describe la complejidad temporal de un algoritmo en términos del tamaño de la entrada, n. En este caso, log n representa el logaritmo en base 2 de n. La notación O se utiliza para describir la complejidad temporal en el peor de los casos de un algoritmo. Por lo tanto, O(log n) significa que el tiempo de ejecución del algoritmo crece proporcionalmente al logaritmo en base 2 del tamaño de la entrada, n.

En términos prácticos, esto significa que a medida que el tamaño de la entrada aumenta, el tiempo de ejecución del algoritmo aumenta lentamente. En contraste, si la complejidad fuera O(n), el tiempo de ejecución del algoritmo crecería proporcionalmente al tamaño de la entrada, lo que sería significativamente más lento a medida que la entrada se hace más grande.

Un ejemplo de un algoritmo con complejidad O(log n) es la búsqueda binaria, que utiliza la división en mitades de un conjunto de datos ordenado para buscar un elemento en particular. En cada iteración, el tamaño del conjunto de datos se reduce a la mitad, lo que implica un crecimiento logarítmico en el número de iteraciones necesarias para encontrar el elemento buscado.    f